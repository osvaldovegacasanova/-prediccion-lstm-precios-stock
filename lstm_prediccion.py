# -*- coding: utf-8 -*-
"""RFvsXGboost.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1c2fke_NMBc_TldaGMDkZ7-ccV5n4AqSG
"""

# --------------------------------------------
# 📦 Instalar librerías necesarias
# --------------------------------------------
# Librerías para descarga de datos financieros, procesamiento y modelado LSTM
# !pip install yfinance ta tensorflow pandas matplotlib scikit-learn

# --------------------------------------------
# 📙 Importar librerías
# --------------------------------------------
import yfinance as yf  # Para descargar datos financieros
import numpy as np      # Para operaciones numéricas
import pandas as pd     # Para manejo de datos estructurados
import matplotlib.pyplot as plt  # Para visualización
from  sklearn.preprocessing import MinMaxScaler  # Escalado de datos
from sklearn.metrics import mean_squared_error  # Métrica de evaluación
from ta.momentum import RSIIndicator  # Indicador técnico RSI
from tensorflow.keras.models import Sequential  # Modelo secuencial
from tensorflow.keras.layers import LSTM, Dense  # Capas LSTM y de salida

# --------------------------------------------
# 📅 Descargar datos desde Yahoo Finance
# --------------------------------------------
ticker = "MSTR"  # Ticker del activo a analizar
# Rango de fechas seleccionadas para capturar contexto reciente (2 años aprox.)
from datetime import datetime, timedelta

# Calcular fechas dinámicas
end_date = datetime.today().date()
start_date = end_date - timedelta(days=3*365)

# Descargar datos desde Yahoo Finance
df = yf.download(ticker, start=start_date, end=end_date)
df = df[["Close"]].rename(columns={"Close": "price"})


# --------------------------------------------
# 🤔 Calcular indicadores técnicos
# --------------------------------------------
df["return_1"] = df["price"].pct_change().fillna(0)  # Retorno simple diario

# RSI: índice de fuerza relativa (momentum). Valor entre 0 y 100
# Se usa como feature adicional para capturar sobrecompra/sobreventa
df["rsi"] = RSIIndicator(close=df["price"].squeeze(), window=14).rsi().fillna(0)

# --------------------------------------------
# 🔄 Normalización de datos
# --------------------------------------------
# Se normalizan los features para que estén en un mismo rango [0, 1]
# Esto ayuda a que la red LSTM converja más rápido y no se sesgue por magnitudes
features = ["price", "return_1", "rsi"]
scaler = MinMaxScaler()
scaled = scaler.fit_transform(df[features])
scaled_df = pd.DataFrame(scaled, columns=features, index=df.index)

# --------------------------------------------
# 📏 Crear dataset multivariado para LSTM
# --------------------------------------------
# Se crean secuencias de longitud fija (ventana) para entrenar la red LSTM
# Cada X contiene una secuencia de 15 pasos y y el valor siguiente a predecir
def create_lstm_dataset(data, target_column="price", window_size=15):
    X, y = [], []
    for i in range(len(data) - window_size):
        X.append(data.iloc[i:i + window_size].values)
        y.append(data.iloc[i + window_size][target_column])
    return np.array(X), np.array(y)

window_size = 15
X, y = create_lstm_dataset(scaled_df, "price", window_size)

# --------------------------------------------
# 🔄 Separar entrenamiento y prueba (80/20)
# --------------------------------------------
split_idx = int(len(X) * 0.8)
X_train, X_test = X[:split_idx], X[split_idx:]
y_train, y_test = y[:split_idx], y[split_idx:]

# --------------------------------------------
# 🧰 Definir modelo LSTM
# --------------------------------------------
# Dos capas LSTM apiladas, la primera devuelve secuencias para la segunda
# Dense(1) es la salida del modelo: una predicción de precio
model = Sequential([
    LSTM(64, return_sequences=True, activation='relu', input_shape=(X.shape[1], X.shape[2])),
    LSTM(32, activation='relu'),
    Dense(1)
])

model.compile(optimizer='adam', loss='mse')  # Se usa error cuadrático medio como función de pérdida
model.fit(X_train, y_train, epochs=50, verbose=1)  # Entrenamiento

# --------------------------------------------
# 📊 Predicción sobre el set de prueba
# --------------------------------------------
y_pred = model.predict(X_test)

# Inversa de la normalización solo para la columna "price"
y_pred_rescaled = scaler.inverse_transform(
    np.concatenate([y_pred, X_test[:, -1, 1:]], axis=1))[:, 0]
y_test_rescaled = scaler.inverse_transform(
    np.concatenate([y_test.reshape(-1, 1), X_test[:, -1, 1:]], axis=1))[:, 0]

# --------------------------------------------
# 📈 Visualización de resultados
# --------------------------------------------
test_dates = df.index[window_size + split_idx:]

plt.figure(figsize=(12, 6))
plt.plot(test_dates, y_test_rescaled, label="Precio real", marker='o')
plt.plot(test_dates, y_pred_rescaled, label="Predicción LSTM multivariado", linestyle='--')
plt.title(f"📈 LSTM Multivariado con {ticker}: Precio vs Predicción")
plt.xlabel("Fecha")
plt.ylabel("Precio (USD)")
plt.legend()
plt.grid(True)
plt.tight_layout()
plt.show()

# --------------------------------------------
# 🔹 RSI en subplot separado
# --------------------------------------------
# Gráfica de RSI para observar condiciones de sobrecompra (>70) o sobreventa (<30)
plt.figure(figsize=(12, 4))
plt.plot(df.index[-len(y_test_rescaled):], df["rsi"].iloc[-len(y_test_rescaled):], color='purple', label='RSI')
plt.axhline(70, color='red', linestyle='--', linewidth=1, label='Sobrecompra (70)')
plt.axhline(30, color='green', linestyle='--', linewidth=1, label='Sobreventa (30)')
plt.title("📊 RSI del activo (ultimo tramo)")
plt.xlabel("Fecha")
plt.ylabel("RSI")
plt.legend()
plt.grid(True)
plt.tight_layout()
plt.show()

# --------------------------------------------
# 🔽 Evaluación del modelo con RMSE
# --------------------------------------------
rmse = np.sqrt(mean_squared_error(y_test_rescaled, y_pred_rescaled))
print(f"🔍 RMSE para {ticker}: {rmse:.2f}")

# --------------------------------------------
# 🔮 Predicción futura (próximo día hábil)
# --------------------------------------------
from datetime import timedelta

# 1. Tomar la última ventana de datos como entrada
last_window = scaled_df[-window_size:].values.reshape(1, window_size, len(features))

# 2. Predecir el siguiente valor normalizado
next_scaled_pred = model.predict(last_window)

# 3. Usar las features complementarias de la última fila
last_extra_features = scaled_df.iloc[-1][["return_1", "rsi"]].values.reshape(1, -1)

# 4. Reconstruir la forma original para desescalar
combined = np.concatenate([next_scaled_pred, last_extra_features], axis=1)
next_predicted_price = scaler.inverse_transform(combined)[0, 0]

# 5. Calcular la fecha del próximo día hábil real
last_date = df.index[-1]
next_business_day = pd.bdate_range(start=last_date, periods=2)[-1]

# 6. Mostrar la predicción
print("🗓️ Último dato disponible:", df.index[-1])
print(f"📅 Predicción para {next_business_day.date()}: ${next_predicted_price:.2f}")

# --------------------------------------------
# 🔍 Verificación de return_1 en datos sin normalizar
# --------------------------------------------

# 1. Calcular retorno manualmente sobre los datos originales
df_verif = df.copy()
df_verif["return_manual"] = df_verif["price"].pct_change()

# 2. Comparar con la columna 'return_1' original (antes del escalado)
# Mostramos solo los primeros valores con diferencias visibles
comparacion = df_verif[["price", "return_manual"]].dropna().head(10)

# 3. Mostrar resultados con formato amigable
print("🧪 Comparación de retornos calculados manualmente vs datos originales:")
display(comparacion)

# --------------------------------------------
# 🪟 Mostrar secuencias reales de 15 pasos (no normalizadas)
# --------------------------------------------

# Parámetros
window_size = 15
num_muestras = 3  # Cuántas ventanas quieres mostrar

# 1. Extraer secuencias del DataFrame original
# Creamos una lista para almacenar DataFrames de ventanas
secuencias = []

for i in range(num_muestras):
    inicio = i
    fin = i + window_size
    ventana_real = df.iloc[inicio:fin][["price", "return_1", "rsi"]].copy()
    ventana_real.index = [f"t-{window_size-j}" for j in range(window_size)]
    secuencias.append(ventana_real)

# 2. Mostrar las secuencias una por una
for idx, sec in enumerate(secuencias):
    print(f"📘 Secuencia real #{idx + 1}")
    display(sec)

# --------------------------------------------
# 📦 Instalar librerías necesarias
# --------------------------------------------
!pip install yfinance ta -q

# --------------------------------------------
# 📚 Importar librerías
# --------------------------------------------
import pandas as pd
import yfinance as yf
from ta.momentum import RSIIndicator

# --------------------------------------------
# 📥 Descargar datos desde Yahoo Finance
# --------------------------------------------
ticker = "MSTR"
df = yf.download(ticker, start="2023-01-01", end="2025-03-24")
df = df[["Close"]].rename(columns={"Close": "price"})

# --------------------------------------------
# 🧠 Calcular features adicionales
# --------------------------------------------
df["return_1"] = df["price"].pct_change().fillna(0)
df["rsi"] = RSIIndicator(close=df["price"].squeeze(), window=14).rsi().fillna(0)

# --------------------------------------------
# 🪟 Generar 500 ventanas horizontales
# --------------------------------------------
window_size = 15
num_muestras = 500

num_muestras = min(num_muestras, len(df) - window_size)

ventanas_formateadas = []

for i in range(num_muestras):
    fila = {}
    for j in range(window_size):
        idx = i + j
        for feature in ["price", "return_1", "rsi"]:
            key = f"{feature}_t-{window_size - j}"
            fila[key] = float(df.iloc[idx][feature])  # 👈 aseguramos que sea float

    # Agregar el target (precio del día siguiente)
    fila["target_price"] = float(df.iloc[i + window_size]["price"])  # 👈 también como float

    ventanas_formateadas.append(fila)

# --------------------------------------------
# 💾 Exportar a CSV limpio
# --------------------------------------------
ventanas_df = pd.DataFrame(ventanas_formateadas)
csv_filename = "ventanas_LSTM_con_target_500_limpio.csv"
ventanas_df.to_csv(csv_filename, index=False)

print(f"✅ Archivo exportado correctamente: {csv_filename}")